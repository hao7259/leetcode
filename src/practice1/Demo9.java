package practice1;

import java.util.Scanner;

/**
 * ClassName: Demo9
 * Package: PACKAGE_NAME
 * Description:
 *
 * @Author 董文强
 * @Create 2024/9/15 0015 15:59
 * @Version v1.0
 * 第一行的状态通过枚举去选，所有状态只有两种选择。要么按一下要不不按。2的5次方
 * 假设我们第一行操作完了。每一个位置只按一次，如果按了两次，相当于没按。按得顺序没有关系。可以任意。
 * 每一行开关的操作完全由前一行灯的亮灭所决定。操作完最后一行，能保证前n-1行是亮着的。此时最后一行的状态不一定全亮。此时看看最后一行
 * 灯有没有灭着的，如果有，说明不合法。
 * 如何枚举第一行的操作。写个递归就行了。（类似于前面做过的指数类型枚举采用递归即可）
 * 第二种可以使用位运算：
 * 11010=》装换成十进制为 16+8+2=26 你会发现每种操作都可以转换成一个十进制数。
 * 所以0-2的5次方-1总共32个数。可以对应32种操作。
 * 因此我们可以写成for循环。
 * for(int i=0;i<32;i++)
 * 因此我们只需要看每一个数的二进制某一位是否是1就行了。1表示亮，0表示不亮。
 * 怎么看i二进制第2位是不是1呢？11010
 * 技巧：我们想看一个数的二进制数从低位到高位某一位k是否是1时，我们可以采用 该数右移k后跟1做与运算。i>>k &1
 * 11010   01101
 * 1   &00001
 * 位数是 43210  想看第一位 这里的二进制表示是用1来表示需要操作，用0表示不需要操作。
 * 如何进行操作 turn怎么开关，传一个坐标（偏移量）
 */
public class Demo9 {
    static int N = 5;
    static int[][] g = new int[5][5];//原数组
    static int[][] backup = new int[5][5];
    static int[] dx = {0, -1, 0, 1, 0};//翻转的时候需要改的x坐标
    static int[] dy = {0, 0, 1, 0, -1};

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();//用来输入共有n个待解决的游戏初始状态。
        //接下来一个一个处理
        while (n-- > 0) {
            for (int i = 0; i < 5; i++) {//每一个初始状态都由5行5列，分别为其赋值，每一行都可以看成是一个字符串
                String s = scanner.next();
                for (int j = 0; j < 5; j++) {//"01101" '0'
                    g[i][j] = s.charAt(j) - '0';//从输入字符串中获取第j位，存入到数组当中。在java中char类型自动转换为int类型。
                    //charAt获取回来的是一个字符‘1’或者字符‘0’，而此时你将一个字符的类型自动转换为int类型。它会将‘1’
                    //或者‘0’字符对应的ascii进行赋值。而1的ascii是49,0的ascii是48。其实我们要的是1或者0.
                    //所以这里做了一个巧妙的设计
                }

            }
            System.out.println(dfs());

        }

    }

    //处理方法
    public static int dfs() {
        int ans = Integer.MAX_VALUE;//这步操作大家先放着。一会就知道它的用途了。

        for (int k = 0; k < 32; k++) {//第一行一共有32种。分别可以用0到31表示。
            int count = 0;//用来做步数的统计
            for (int i = 0; i < 5; i++) {
                System.arraycopy(g[i], 0, backup[i], 0, 5);
            }//这里为啥要做备份呢？不备份行不行,因为第一种方案假设不行了以后，还得进行第二种，我们还得恢复到没操作之前。继续判断第二种方案是否可行。
            for (int j = 0; j < 5; j++) {//先用来对第一行做个操作。这里的op从1~31，因为是位运算，所以是1~31的二进制和1的二进制从右向左进行与的操作，比如10100(20)的op，意思是第2、4位（右到左01234）需要按，不是代表灯有没有亮，32种状态其实是哪些灯要按，一种k对应一种固定的按法，所以是&1==1或者^1==0。
                if (((k >> j) & 1) == 1) {//所以是&1==1表示需要操作或者^1==0表示不需要操作
                    count++;
                    turn(0, j);
                }
            }
            //通过第一行只会被第二行影响。第二行只会被第三行影响。
            for (int i = 0; i < 4; i++) {
                for (int j = 0; j < 5; j++) {
                    if (g[i][j] == 0) {
                        count++;
                        turn(i + 1, j);
                    }
                }
            }
            //接下来我们看一下最后一行。遍历最后一行，只要最后一行有一个0，说明这样做法不行。继续下一种做法。
            boolean is_success = true;//定义一个标志位。初始值为true.
            for (int j = 0; j < 5; j++) {
                if (g[4][j] == 0) {//如果最后一行有一个0说明不行，直接结束。
                    is_success = false;
                    break;
                }
            }
            //否则说明最后一行都是1，说明方案可以，但是要看一下count的值是否小于等于6，因为题目要求6步走完。
            if (is_success) {
                ans = Math.min(ans, count);
            }
            for (int i = 0; i < 5; i++) {
                System.arraycopy(backup[i], 0, g[i], 0, 5);
            }            //继续下一种可能得操作
        }

        if (ans > 6) {
            return -1;
        }
        return ans;
    }

    private static void turn(int x, int y) {
        for (int i = 0; i < 5; i++) {//循环5次，为啥？因为不仅要变自己，还要把自己上下左右都变一下。
            int a = x + dx[i];
            int b = y + dy[i];
            if (a < 0 || a >= 5 || b < 0 || b >= 5) {
                continue;
            } else {
                if (g[a][b] == 1) {
                    g[a][b] = 0;
                } else {
                    g[a][b] = 1;
                }
            }
        }
    }
}
/*
    你看第一次k=0的时候，二进制是000000
    在下面这个j的循环中计算结果一直是0
    k=1的时候，二进制：00001
    在第一次循环k>>0，相当于啥也没干，最后一位是1，判断就是true，意思是按一下第五个灯，剩下都是0，也就都是false
    k=6的时候，二进制：00110
    第一次00110>>0=00110,最后一位是0，false
    第二次00110>>1=00011,最后一位是1，true
    第二次00110>>2=00001,最后一位是1，true
    后面是false
 */

